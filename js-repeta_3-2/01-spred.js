//! Видео - 0:00:30...0:31:50

/*
* Операция spread (распыление)
* - Array.prototype.concat() и аналог через spread
*/
console.groupCollapsed('Операция spread (распыление)'); //! Log group name

// 1-й вариант создания объединенного массива
const numbers = [1, 2, 3].concat([4, 5, 6], [7, 8, 9]);
console.log('1-й вариант ->', numbers); // Выводим результат объединения в лог

// 2-й вариант создания объединенного массива
const numbers2 = [...[1, 2, 3], ...[4, 5, 6], ...[7, 8, 9]];

console.log('2-й вариант ->', numbers2); // Выводим результат объединения в лог

//! Метод распыления является более универсальным и гибким в применении.

console.groupEnd(); //! Log group end
console.log('-1----------------------------------------------');


/*
* Поиск самой маленькой или большой температуры (числа)
*/
console.groupCollapsed('Поиск самой маленькой или большой температуры (числа)'); //! Log group name

// У нас есть переменная с массивом значений температур, и нам нужно найти среди этих температур самую маленькое и самое большое значение с попощью методов "Math.min" и "Math.max".
const temps = [18, 14, 12, 21, 17, 29, 24]; // Переменная с массивом значений
console.log('Исходный массив ->', temps); // Выводим в лог исходный массив

// Важной особенностью использования методов "Math.min" и "Math.max" является то, что они выполняют поиск нужных значений среди набора (группы) не связаных между собой, отдельных аргументов (значений), и не работают с набором значений в массиве (массив для этих методов - является одним значением, а не группой). Поэтому, для решения нашей задачи, нам необходимо разделить или "распылить" набор значений массива "temps", и уже среди "распыленных" отдельных значений найти наибольшее и наименьшее число.

// Выполняем операцию вывода в лог наибольшего значения массива с использованием процедуры "распыления"
console.log('Наибольшая температура =', Math.max(...temps));

// Выполняем операцию вывода в лог наибольшего значения массива с использованием процедуры "распыления"
console.log('Наименьшая температура =', Math.min(...temps));

// Важной особенностью функционирования метода "распыления" является то, что при его использовании исходный "распыляемый" объект остается неизменным. Создаются копии всех его элементов, в качестве отдельных объектов.

// Создаем переменную "а" и задаем ей значение в виде массива
const a = [1, 2, 3];
console.log('Значение переменной "а" =', a);

// Создаем переменную "b" и задаем ей значение в виде массива из "распыленной" переменной "а"
const b = [...a];
console.log('Значение переменной "b" =', b);

// Сравниваем значение двух переменных между собой
console.log('Результат сравнения "a === b" ->', a === b);

// Как мы можем видеть в консоли, две сравниваемые переменные, и соответственно два находящихся в них массива - не равны между собой. Это подтверждает тот факт, что при "распылении" создается новые объекты, которые потом, в нашем примере, были объеденены в новый массив.



// При "распылении" массива объектов, таким же оброзом происходит копирование распыляемых объектов. Однако, при этом составные элементы таких массивов являясь сложными объектами сами по себе, будут скопированны ссылками, а не воссозданы отдельно. В результате чего, они могут быть равными (по ссылке), находясь при этом в разных массивах.

// Создаем переменную "а2" и задаем ей значение в виде массива объектов
const a2 = [{ a: 1 }, { b: 2 }, { c: 3 }];
console.log('Значение переменной "а2" =', a2);

// Создаем переменную "b2" и задаем ей значение в виде массива из "распыленной" переменной "а2"
const b2 = [...a2];
console.log('Значение переменной "b2" =', b2);

// Производим сравнение двух массивов между собой
console.log('Сравниваем значение переменных "a2 === b2 ->"', a2 === b2);

// Производим сравнение двух первых элементов массивов между собой
console.log('Сравниваем значение двух первых элементов массивов "a2[0] === b2[0] ->"', a2[0] === b2[0]);

// В последнем примере мы увидели, что два массива не равны между собой. Однако два их первых элемента - равны. Это связано с тем, что при распылении сложных типов делается не копия, а ссылка на оригинальный сложный элемент.

console.groupEnd(); //! Log group end
console.log('-2----------------------------------------------');


/*
* Сшиваем несколько массивов в один через concat() и spread
*/
console.groupCollapsed('Совмещаем несколько массивов в один через concat() и spread'); //! Log group name

// У нас есть 3-и массива и нам нужно их соеденить в один
const lastWeekTemps = [1, 2, 3];
const currentTemps = [4, 5, 6];
const nextWeekTemps = [7, 8, 9];

//! "Сшиваем" массивы с помощь "concat()"
const allTempsConcat = lastWeekTemps.concat(currentTemps, nextWeekTemps);
console.log('"Сшитый" с помощь "concat()" массив ->', allTempsConcat);

//! "Сшиваем" массивы с помощь "spread (распыления)"
const allTempsSpread = [...lastWeekTemps, ...currentTemps, ...nextWeekTemps];
console.log('"Сшитый" с помощь "spread (распыления)" массив ->', allTempsSpread);

console.groupEnd(); //! Log group end
console.log('-3----------------------------------------------');


/*
* Распыление объектов
* - Object.prototype.assign() и spread
*/
console.groupCollapsed('Распыление объектов'); //! Log group name

// У нас есть 2-а объекта, из которых нужно сделать один
const a3 = { x: 1, y: 2 };
const b3 = { x: 0, z: 3 };

// Создаем единый объект с помощью метода "Object.prototype.assign()"
const c = {}; // Создаем переменную прототип, в которую будем собирать еденый объект

// Производим операцию сшивки
Object.assign(c, a3, b3);
console.log('"Сшитый" с помощь "Object.assign()" объект ->', c);


// Создаем единый объект с помощью метода "spread (распыления)"
const c2 = { ...a3, ...b3 };
console.log('"Сшитый" с помощь "spread (распыления)" объект ->', c2);


// Важной особенностью использования современного метода распыления при создании массивов - является то, что на создоваемый общий-сшитый массив влияет последовательность распыляемых исходных массивов, в соответствии с которой выстраивается последовательность объединенного массива.
// При создании объектов - порядок распыления влияет на конечные значения в одинаковых свойствах. В результате чего, это дает дополнительные возможности к изменению значений свойств объектов, путем подбора нужной последовательности их "распыления" и "сшивки" в единый объект.

const c3 = {
    ...a3,
    x: 10,
    ...b3,
    y: 20,
}
console.log('"Сшитый" с помощь "распыления" в нужной последовательности объект ->', c3);

console.groupEnd(); //! Log group end
console.log('-4----------------------------------------------');


/*
* Пример использования распыляния для изменения некоторох настроек сайта, параметры которого объеденены в объект
*/
console.groupCollapsed('Пример использования распыляния для изменения параметров настройки сайта'); //! Log group name

// Исходный набор "дефолтных" настроек сайта, объедененный в один объект - "defoltSettings".
const defoltSettings = {
    theme: 'light',
    showNotifications: true,
    hideSiteBar: false,
};
console.log('"defoltSettings" =>', defoltSettings);

// Набор настроек, которые изменил пользователь, объедененный в один объект - "userSettings".
const userSettings = {
    showNotifications: false, //! Пользователь изменил
    hideSiteBar: true, //! Пользователь изменил
};
console.log('"userSettings" =>', userSettings);

// Настройки сайта, которые применились, объедененный в один объект - "finslSettings". Перечень настроек создается автоматически с помощью операции распыления двух выше описанных объектов.
const finslSettings = {
    ...defoltSettings,
    ...userSettings,
};
console.log('"finslSettings" =>', finslSettings);

console.groupEnd(); //! Log group end
console.log('-5----------------------------------------------');

