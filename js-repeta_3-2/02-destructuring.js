//! Видео - 0:32:00...

/*
* Деструктуризация объекта
* - Значение по умолчанию
* - Имя переменной отличное от имени свойства
*/
// Операция "деструкторизации" предназначена для того, чтобы предоставить доступ к свойствам объектов с уменьшенным количеством кода обращений. Она позволяет убрать повторяющиеся фрагменты кода, которые возникают при многочисленных обращениях к свойствам объекта в скрипте.

// Например, у нас есть объект, свойства которого нужно вывести в лог.
const playlist = {
    name: 'Мой супер плейлист',
    rating: 5,
    tracks: ['трек-1', 'трек-2', 'трек-3'],
    trackCount: 3,
};

// Пишем стандартный код-обращение к каждому отдельному свойству объекта для вывода его в лог. 
console.log(
    'Прямое обращение к свой-ам объекта ->',
    playlist.name,
    playlist.rating,
    playlist.tracks,
    playlist.trackCount,
);
// В подобном перечне обращений мы каждый раз повторяем запись " playlist", указывая объект к которому мы обращаемся.


// Деструкторизация соответствующего объекта, поозволяет обращаться к его свойствам напрямую, без необходимости указывать в каждом обращении имя соответствующего объекта и способствует уменьшению кода в скрипте.


// Производим операцию деструкторизации нашего объекта
const { name, rating, tracks, trackCount} = playlist;

// Пишем код-обращение к каждому отдельному свойству деструктуризированного объекта как к обычной переменной скрипта. 
console.log(
    'Обращение к деструктуризированным свой-ам объекта ->',
    name,
    rating,
    tracks,
    trackCount,
);
// Как мы видим, процедура деструкторизации объекта позволяет создать-преобразовать набор свойств соответствующего объекта в набор локальных переменных скрипта, с соответствующими именами. При этом, если в качестве значений свойств присвоен примитив (число, текст, буль) - делается копия этого значения в автоматически создоваемую "новую" переменную, а если в качестве значений свойств присвоен сложный объект (массив или объект), то создается ссылка на уже существующую ячейку памяти, в которой находится этот объект.


// Кроме того, операция деструкторизации позволяет устанавливать значения "по умолчанию" для деструкторизированных свойств объекта и "пере-называть (давать новое имя)" создоваемым таким образом переменным скрипта.

// Пример установки значения "по умолчанию"
// Исходный объект - "playlist2"
const playlist2 = {
    name2: 'Мой супер плейлист',
    rating2: 5,
    tracks2: ['трек-1', 'трек-2', 'трек-3'],
    trackCount2: 3,
};

// Производим деструкторизацию объекта "playlist2" одновременно с установкой значений "по умолчанию" для нескольких из его свойств. 
const {
    name2,
    rating2,
    tracks2,
    trackCount2 = 5,
    autor = 'user',
} = playlist2;

// Выводим в лог значение свойства с существующим в объекте значением
console.log('Свой-во с существующим значением ->', trackCount2);
// Как можно видеть по логу, свойство с существующим значением - игнорирует выставленое при деструкторизации значение "по умолчанию", и отображает в логе исходное значение, которое было присвоено этому свойству в объекте.

// Выводим в лог значение не существующего в объекте свойства значением
console.log('Значение, не существующего в объекте свойства "autor" ->', autor);
// Основное назначение установки подобных значений "по умолчанию" предназначено именно для тех свойств, имена и значения которых, нужны в скрипте, но могут НЕ находится в деструкторизируемом объекте. 


// Пример "пере-называния" создоваемых переменных
// Исходный объект - "playlist3"
const playlist3 = {
    name3: 'Мой супер плейлист',
    rating3: 5,
    tracks3: ['трек-1', 'трек-2', 'трек-3'],
    trackCount3: 3,
};

// Производим деструкторизацию объекта "playlist3" одновременно с "пере-называнием" одного из его свойств
const {
    name3,
    rating3,
    tracks3,
    trackCount3: numberOfTracks, // "Пере-называем"
} = playlist3;

// Выводим в лог значение "пере-названого" свойства
console.log('Переназванное свой-во "trackCount3" ->', numberOfTracks);
// Нужно отметить, что попытка вместо нового имени переменной - "numberOfTracks" использовать исходное соответствующей переменной - "trackCount3", вызывает ошибку. После выполнения операции "пере-называния" исходное имя соответствующей переменной - нельзя использовать.



/*
* Глубокая деструктуризация
*/
// Данный вид деструкторизации предназначен для деструкторизации вложеных в объекты сложные типы данных (массивы и объекты).

// Объект с вложенным в него сложным типом данных в свойство "stats"
const profile = {
    userName: 'Jacques Gluke',
    tag: 'jqluke',
    location: 'Ocho Rios, Jamaica',
    avatar: 'https://s3.amazonaws.com/uifaces/faces/twitter/r_oy/128.jpg',
    stats: {
        followers: 5603,
        views: 4827,
        likes: 1308,
    },
};

// Обычная, одинарная деструкторизация объекта "profile", не позволит "разобрать" на состовляющие свойство "stats". После подобной одинарной деструкторизации, в свойстве "stats" будет находится объект. Для проведения более глубокой деструкторизации, и "разбора" на составные элементы еще и свойства "stats", необходимо отдельно выполнить еще и деструкторизацию этого свойства

// Одинарная деструкторизация объекта "profile"
const { userName, tag, location, avatar, stats } = profile; 
console.log('Сложное свойство, после одинарной деструкторизации ->', stats);

// Дополнительная деструкторизация свойства "stats"
const { followers, views, likes } = stats;
console.log('Элемент сложного свойства объекта - "followers", после дополнительной деструкторизации ->', followers);


// Второй способ проведения глубокой деструкторизации - основан на использовании метода "переименования" свойств объектов при их деструкторизации, и синтаксически выглядит как переименование "сложного" свойства объекта на вложенные в него свойства объекта второго уровня.

// Исходный объект со вложеным в него "сложным" свойством
const profile2 = {
    userName2: 'Jacques Gluke',
    tag2: 'jqluke',
    location2: 'Ocho Rios, Jamaica',
    avatar2: 'https://s3.amazonaws.com/uifaces/faces/twitter/r_oy/128.jpg',
    stats2: {
        followers2: 5603,
        views2: 4827,
        likes2: 1308,
    },
};

// Деструкторизация объекта "profile2" с использованием метода "переименовки" для деструкторизации "сложного" свойства
const {
    userName2,
    tag2,
    location2,
    avatar2,
    stats2: { followers2, views2, likes2 },
} = profile2;
console.log('Элемент сложного свойства объекта - "followers", после деструкторизации c использованием метода "переименовки" ->', followers2);



/*
* Деструктуризация массивов
*/
// Производится по порядку расположения в нем составных элементов

// Массив "rgb"
const rgb = [255, 100, 80];
console.log('Массив ->', rgb);

// Деструкторизация значений массива "rgb" в переменные
const [red, green, blue] = rgb;
console.log('Деструктуризированное значение первого (нулевого по регистру) элемента массива ->', red);

// const authors = {
//     kiwi: 4,
//     poly: 7,
//     ajax: 9,
//     mango: 6,
// } 

/*
* Операция rest (сбор)
*/

const profile4 = {
    name4: 'Jacques Gluke',
    tag4: 'jqluke',
    location4: 'Ocho Rios, Jamaica',
    avatar4: 'https://s3.amazonaws.com/uifaces/faces/twitter/r_oy/128.jpg',
    stats4: {
        followers4: 5603,
        views4: 4827,
        likes4: 1308,
    },
};

const { name4, tag4, location4, ...restProps } = profile4;

console.log(name4, tag4, location4);
console.log(restProps);
console.log(profile4);



/*
* Патерн "Объект настроек"
* - деструкторизация параметра-объекта в подписи функции;
* - rest при деструкторизации в подписи.
*/
// Патерн "Объект настроек" используется в функциях, в которые необходимо передавать 3-и, и более параметров. Он предназначен для структоризации параметров, которые передаются в функцию, и позволяет не только передать, но и описать суть значений каждого передаваемого в функцию параметра. Собственно в функцию (в которую необходимо передавать 3-и, и более параметров), передается не набор отдельных аргументов параметров, а один объект, в котором содержится нужный набор параметров, проименованный с помощью названия свойств объекта, содержащих нужные аргументы соответствующих параметров функции.

// При использовании патерна "Объект настроек", деструкторизацию передаваемого в функцию объекта можно проводить как в подписи самого объекта (в скобках, расположенных после названия функции), так и внутри тела самой функции.
