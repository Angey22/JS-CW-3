//! Видео - 0:32:00...1:25:50

/*
* Деструктуризация объекта:
* - значение по умолчанию;
* - имя переменной отличное от имени свойства.
*/
console.groupCollapsed('Деструктуризация объекта'); //! Log group name

// Операция "деструкторизации" предназначена для того, чтобы предоставить доступ к свойствам объектов с уменьшенным количеством кода обращений. Она позволяет убрать повторяющиеся фрагменты кода, которые возникают при многочисленных обращениях к свойствам объекта в скрипте.

// Например, у нас есть объект, свойства которого нужно вывести в лог.
const playlist = {
    name1: 'Мой супер плейлист',
    rating1: 5,
    tracks1: ['трек-1', 'трек-2', 'трек-3'],
    trackCount1: 3,
};

// Пишем стандартный код-обращение к каждому отдельному свойству объекта для вывода его в лог. 
console.log(
    'Прямое обращение к свой-ам объекта ->',
    playlist.name1,
    playlist.rating1,
    playlist.tracks1,
    playlist.trackCount1,
);
// В подобном перечне обращений мы каждый раз повторяем запись " playlist", указывая объект к которому мы обращаемся.


// Деструкторизация соответствующего объекта, позволяет обращаться к его свойствам напрямую, без необходимости указывать в каждом обращении имя соответствующего объекта и способствует уменьшению кода в скрипте.


// Производим операцию деструкторизации нашего объекта
const { name1, rating1, tracks1, trackCount1} = playlist;

// Пишем код-обращение к каждому отдельному свойству деструктуризированного объекта как к обычной переменной скрипта. 
console.log(
    'Обращение к деструктуризированным свой-ам объекта ->',
    name1,
    rating1,
    tracks1,
    trackCount1,
);
// Как мы видим, процедура деструкторизации объекта позволяет создать-преобразовать набор свойств соответствующего объекта в набор локальных переменных скрипта, с соответствующими именами. При этом, если в качестве значений свойств присвоен примитив (число, текст, буль) - делается копия этого значения в автоматически создоваемую "новую" переменную, а если в качестве значений свойств присвоен сложный объект (массив или объект), то создается ссылка на уже существующую ячейку памяти, в которой находится этот объект.


// Кроме того, операция деструкторизации позволяет устанавливать значения "по умолчанию" для деструкторизированных свойств объекта и "пере-называть (давать новое имя)" создоваемым таким образом переменным скрипта.

// Пример установки значения "по умолчанию"
// Исходный объект - "playlist2"
const playlist2 = {
    name2: 'Мой супер плейлист',
    rating2: 5,
    tracks2: ['трек-1', 'трек-2', 'трек-3'],
    trackCount2: 3,
};

// Производим деструкторизацию объекта "playlist2" одновременно с установкой значений "по умолчанию" для нескольких из его свойств. 
const {
    name2,
    rating2,
    tracks2,
    trackCount2 = 5,
    autor = 'user',
} = playlist2;

// Выводим в лог значение свойства с существующим в объекте значением
console.log('Свой-во с существующим значением ->', trackCount2);
// Как можно видеть по логу, свойство с существующим значением - игнорирует выставленое при деструкторизации значение "по умолчанию", и отображает в логе исходное значение, которое было присвоено этому свойству в объекте.

// Выводим в лог значение не существующего в объекте свойства значением
console.log('Значение, не существующего в объекте свойства "autor" ->', autor);
// Основное назначение установки подобных значений "по умолчанию" предназначено именно для тех свойств, имена и значения которых, нужны в скрипте, но могут НЕ находится в деструкторизируемом объекте. 


// Пример "пере-называния" создоваемых переменных
// Исходный объект - "playlist3"
const playlist3 = {
    name3: 'Мой супер плейлист',
    rating3: 5,
    tracks3: ['трек-1', 'трек-2', 'трек-3'],
    trackCount3: 3,
};

// Производим деструкторизацию объекта "playlist3" одновременно с "пере-называнием" одного из его свойств
const {
    name3,
    rating3,
    tracks3,
    trackCount3: numberOfTracks, // "Пере-называем"
} = playlist3;

// Выводим в лог значение "пере-названого" свойства
console.log('Переназванное свой-во "trackCount3" ->', numberOfTracks);
// Нужно отметить, что попытка вместо нового имени переменной - "numberOfTracks" использовать исходное соответствующей переменной - "trackCount3", вызывает ошибку. После выполнения операции "пере-называния" исходное имя соответствующей переменной - нельзя использовать.

console.groupEnd(); //! Log group end
console.log('-1----------------------------------------------');


/*
* Глубокая деструктуризация
*/
console.groupCollapsed('Глубокая деструктуризация'); //! Log group name

// Данный вид деструкторизации предназначен для деструкторизации вложеных в объекты сложные типы данных (массивы и объекты).

// Объект с вложенным в него сложным типом данных в свойство "stats"
const profile = {
    userName: 'Jacques Gluke',
    tag: 'jqluke',
    location: 'Ocho Rios, Jamaica',
    avatar: 'https://s3.amazonaws.com/uifaces/faces/twitter/r_oy/128.jpg',
    stats: {
        followers: 5603,
        views: 4827,
        likes: 1308,
    },
};

// Обычная, одинарная деструкторизация объекта "profile", не позволит "разобрать" на состовляющие свойство "stats". После подобной одинарной деструкторизации, в свойстве "stats" будет находится объект. Для проведения более глубокой деструкторизации, и "разбора" на составные элементы еще и свойства "stats", необходимо отдельно выполнить еще и деструкторизацию этого свойства

// Одинарная деструкторизация объекта "profile"
const { userName, tag, location, avatar, stats } = profile; 
console.log('Сложное свойство, после одинарной деструкторизации ->', stats);

// Дополнительная деструкторизация свойства "stats"
const { followers, views, likes } = stats;
console.log('Элемент сложного свойства объекта - "followers", после дополнительной деструкторизации ->', followers);


// Второй способ проведения глубокой деструкторизации - основан на использовании метода "переименования" свойств объектов при их деструкторизации, и синтаксически выглядит как переименование "сложного" свойства объекта на вложенные в него свойства объекта второго уровня.

// Исходный объект со вложеным в него "сложным" свойством
const profile2 = {
    userName2: 'Jacques Gluke',
    tag2: 'jqluke',
    location2: 'Ocho Rios, Jamaica',
    avatar2: 'https://s3.amazonaws.com/uifaces/faces/twitter/r_oy/128.jpg',
    stats2: {
        followers2: 5603,
        views2: 4827,
        likes2: 1308,
    },
};

// Деструкторизация объекта "profile2" с использованием метода "переименовки" для деструкторизации "сложного" свойства
const {
    userName2,
    tag2,
    location2,
    avatar2,
    stats2: { followers2, views2, likes2 }, //!!!
} = profile2;
console.log('Элемент сложного свойства объекта - "followers", после деструкторизации c использованием метода "переименовки" ->', followers2);

console.groupEnd(); //! Log group end
console.log('-2----------------------------------------------');


/*
* Деструктуризация массивов
*/
console.groupCollapsed('Деструктуризация массивов'); //! Log group name

// Производится по порядку расположения в нем составных элементов

// Массив "rgb"
const rgb = [255, 100, 80];
console.log('Массив =>', rgb);

// Деструкторизация значений массива "rgb" в переменные
const [red, green, blue] = rgb;
console.log('Деструктуризированное значение первого (нулевого по регистру) элемента массива в переменную "red" =>', red);
console.log('------------------------------------------------');

//! Пример использования деструкторизации массивов
// У нас есть перечень авторов со значениями их текущего рейтинга, который объединен в объект. Нам нужно вывисти в консоль отдельно имя автора и его рейтинг в одной строке, и так со всеми авторами находящимися в базе данных.

// Исходный объект - база данных
const authors = {
    kiwi: 4,
    poly: 7,
    ajax: 9,
    mango: 6,
};
console.log('Объект "authors" =>', authors);

// Создаем переменную и присваиваем ей значение массива массивов созданого с помощью метод "Object.entries()"
const entries = Object.entries(authors);
console.log('Массив массивов "entries" =>', entries);

// Создаем цыкл для перебора и автоматического вывода в лог нужной нам информации про каждого автора и его рейтинг.
for (const [name, rating] of entries) { //! Деструктуризируем массив прямо в условии цыкла

    //! Деструктуризируем массив внутри тела цикла
    // const [name, rating] = author;

    console.log('Автор из базы =>', name, rating);
};

console.groupEnd(); //! Log group end
console.log('-3----------------------------------------------');


/*
* Операция rest (сбор)
*/
console.groupCollapsed('Операция rest (сбор)'); //! Log group name

// Исходный объект подлежащий деструкторизации
const profile4 = {
    name4: 'Jacques Gluke',
    tag4: 'jqluke',
    location4: 'Ocho Rios, Jamaica',
    avatar4: 'https://s3.amazonaws.com/uifaces/faces/twitter/r_oy/128.jpg',
    stats4: {
        followers4: 5603,
        views4: 4827,
        likes4: 1308,
    },
};

// Пример объединения некоторых свойств в отдельный набор-объект, при деструкторизации с помощью операци "rest".
const { name4, tag4, location4, ...restProps } = profile4;
//! В результате мы получаем три локальные переменные с соответствующими литералами примитивов в качестве значений, и одну переменную с литералом объекта в качестве значения. Данный способ сбора в одну группу переменных удобен в тех случаях, когда не нужно напрямую использовать все свойства из деструкторизируемого объекта.

// Выводим в лог отдельно прописанные при деструкторизации свойства объекта
console.log('"name4, tag4, location4" =>', name4, tag4, location4);

// Выводим в лог собранный в группу-объект при деструкторизации свойства объекта
console.log('"restProps" =>', restProps);

// Выводим в лог сам объект, который подлежит деструкторизации
console.log('"profile4" =>', profile4);

console.groupEnd(); //! Log group end
console.log('-4----------------------------------------------');


/*
* Патерн "Объект настроек"
* - деструкторизация параметра-объекта в подписи функции;
* - rest при деструкторизации в подписи.
*/
console.groupCollapsed('Патерн "Объект настроек"'); //! Log group name

// Патерн "Объект настроек" используется в функциях, в которые необходимо передавать 3-и, и более параметров. Он предназначен для структоризации параметров, которые передаются в функцию, и позволяет не только передать, но и описать суть значений каждого передаваемого в функцию параметра. Собственно в функцию (в которую необходимо передавать 3-и, и более параметров), передается не набор отдельных аргументов параметров, а один объект, в котором содержится нужный набор параметров, проименованный с помощью названия свойств объекта, содержащих нужные аргументы соответствующих параметров функции.

// При использовании патерна "Объект настроек", деструкторизацию передаваемого в функцию объекта можно проводить как в подписи самого объекта (в скобках, расположенных после названия функции), так и внутри тела самой функции.

console.groupEnd(); //! Log group end
console.log('-5----------------------------------------------');
