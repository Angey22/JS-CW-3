//! Видео - 0:45:00...

/*
 * Методы объекта и this при обращении к свойствам в методах
 *
 * http://fecore.net.ua/books/m5ph3r-javascript/module-03/images/context.jpg
 *
 * - changeName
 * - addTrack
 * - updateRating
 * - getTrackCount
 */
// Внутри каждого отдельного свойства объекта можно создать функцию (присвоив в качестве значения свойства - функцию), которая будет выступать в качестве "метода" этого объекта. Методы отдельно взятого объекта предназначены для работы со свойствами только этого объектка, и больше ни с чем.

// Пример объекта с функцией присвоенной в качестве значения одному из свойств данного объекта
const playlist = {
  name: 'Мой супер плейлист',
  rating: 5,
  tracks: ['трек-1', 'трек-2', 'трек-3'],
  trakCount: 3,
  getName: function () {
    // Данная функция выполняет вывод текстового сообщения
    console.log('Ага это getName :)')
  },
};

console.log(playlist); // Выводим в лог объект
playlist.getName(); // Активируем соответствующую функцию

// Созданная подобным образом функция, принципиально ни чем не отличается от любой другой функции созданой отдельно, и так же может содержать параметры и принимать в них аргументы

const playlist2 = {
  name: 'Мой супер плейлист',
  rating: 5,
  tracks: ['трек-1', 'трек-2', 'трек-3'],
  trakCount: 3,
  getName: function (a) {
    // Данная функция выполняет вывод текстового сообщения
    console.log('Ага это getName :) с заданым аргументом =', a)
  },
};

playlist2.getName(5); // Активируем соответствующую функцию с заданым аргументом

// Существует два вида синтаксической записи объявления функции "внутри" свой-ва объекта:
// 1-й "олдскульный" -> 'getName: function () {тело функции}';
// 2-й "современный" -> 'getName() {тело функции}';
// Оба эти способа работают одинаково, но предпочтительнее использовать более современный вид, т.к. при его использовании меньше кода. + "Современный" способ синтаксической записи называется - "метод объекта".

// Важной особенностью работы с методами объектов является то, что в них НЕЛЬЗЯ использовать имя самого объекта.
// Внутри каждой функции есть служебное ключевое слово "this", использование которого позволяет обращаться и/или ссылаться на тот объект, который вызвал соответствующую функцию.

// Пример объекта с использованием внутри него служебного ключевого слова - "this", и, "современный" способ синтаксической записи объявления функции "внутри" свой-ва объекта.
const playlist3 = {
  name: 'Мой супер плейлист',
  rating: 5,
  tracks: ['трек-1', 'трек-2', 'трек-3'],
  changeName(newName) { // Объявление функции "внутри" свой-ва объекта
    console.log('this внутри changeName: ', this); // Выводим в "лог" элемент скрипта, на который можно сослаться с помощью служебного ключевого слова - "this"

    this.name = newName; // С помощью служебного ключевого слова "this" - задаем свойству объекта "name" новое текстовое значение, в виде параметра соответствующей функции "newName", который передается в функцию при ее вызове. 
  },
    addTrack(track) { // Объявление функции "внутри" свой-ва объекта
    this.tracks.push(track); // С помощью служебного ключевого слова "this" - обращаемся к свойству объекта "tracks", и методом "push", добавляем новый элемент (находящийся в параметре функции), в существующий в нем массив
  },
  updateRating(newRating) { // Объявление функции "внутри" свой-ва объекта
    this.rating = newRating; // С помощью служебного ключевого слова "this" - присваиваем свойству объекта "rating" новое значение, в виде параметра соответствующей функции "newRating", который передается в функцию при ее вызове.
  },
  getTrackCount() { // Объявление функции "внутри" свой-ва объекта
    return this.tracks.length; // С помощью служебного ключевого слова "this" - автоматически вычисляем "длину" массива, численное значение которой соответствует количеству условных треков в плейлисте
  },
};

playlist3.changeName('Новое имя XXX'); // Задаем параметру функции нужный аргумент (т.е., новое текстовое значение для свойства объекта).
playlist3.addTrack('новый трек 1'); // Задаем параметру функции нужный аргумент (т.е., новый элемент массива, записанный в соответствующем свойстве объекта).
playlist3.updateRating(3); // Задаем параметру функции нужный аргумент (т.е., новое значение, которое записывается в соответствующее свойство объекта).

console.log(playlist3); // Выводим в лог объект, после активации вложенной в нем функции изменения имени одного из его свойств.



// Еще одной особенностью работы с динамически-изменяемыми объектами, т.е. объектами внутри которых свойства могут изменять свое значение, является то, что внутри таких объектов - лучше не использовать статические параметры - показатели соответствующих свойств, а применять для записи таких параметров - функции. Например, в нашем объекте (использованном в вышеописанном примере) есть свойство "tracks", которому присвоено значение - массив с набором условных треков (элементов этого массива), и отдельное должно быть свойство "trakCount" - которое содержит численное значение количества треков, находящихся в соответствующем массиве. С учетом того, что массив находящийся в свойстве "tracks" может динамически изменятся, соответственно и численное значение количества треков может изменятся. В этих условиях - свойство объекта со значением количества треков в плей-листе НЕ нужно делать в виде статичного значения (что бы не нужно было его изменять вручную), а лучше выполнить в виде отдельного свойства объекта-функции, которая при динамическом изменении количества треков - автоматически вычислит нужное число. Примером вышеописанной реализации является метод объекта "getTrackCount()", который автоматически возвращает число - значение длины соответствующего массива с треками, при активации этой функции.

console.log('Выводим количество треков в плей-листе ->', playlist3.getTrackCount());
