// ! Видео - 0:00:00...0:00:00

/*
 * Объекты (делаем плейлист музыки: имя, рейтинг, треки, кол-во треков):
 * - литерал объекта;
 * - свойства, ключи (имя) и значения;
 * - как отличить объект от области видимости.
 */
console.groupCollapsed('Объекты: литерал объекта; свойства, ключи (имя) и значения; отличие объекта от области видимости.'); //! Log group name

// Пример записи объекта с группой свойств внутри
const playlistEx = {
  name: 'Мой супер плейлист',
  rating: 5,
  tracks: ['трек-1', 'трек-2', 'трек-3'],
  trackCount: 3,
};

console.log(playlistEx); // Вывод в консоль объекта "playlist"

// const x = {}; // 1-й приимер записи объекта, процедуры присваивания переменной значения в виде объекта

// console.log({}); // 2-й приимер записи объекта, процедуры вывода в консоль значения переменной в виде объекта. Данная запись аналогична 1-у примеру, т.к. в этом случае тоже осуществляется операция присвоения некой служебной переменной значение в виде объекта, после чего, это значение выводится в лог.

// 3-й пример. Основан на использовании фун-ии "fn", в которую задается параметр в виде объекта
const fn = function (myObject) // Объявляем фун-ию, и задаем в ней возможность использования аргумента в виде переменной "myObject"
{
  console.log(myObject); // Выводим в лог значение переменной "myObject"
  // Нужно отметить, что при передаче в функцию значения аргумента в виде объекта, так же как и в 1-м примере происходит операция присвоения переменной значения - "myObject = { a: 1, b: 2 }"
};

// Вызываем функцию "fn" и задаем ей параметр в виде значения - объекта
fn({ a: 1, b: 2 });

// 4-й пример. Основан на использовании фун-ии "rtfm", из которой возвращается параметр виде объекта
const rtfm = function () // Объявляем фун-ию
{
  return { a: 5 }; // Производим внутри ф-ии некие манипуляции, в результате которых ф-ия возвращает "на выходе" - объект
};

console.log(rtfm()); // Выводим в лог результат работы ф-ии "rtfm"

// Любой объект - это просто значение, точно такое же, как и число, строка, "буль" и т.д.

console.groupEnd(); //! Log group end
console.log('-1----------------------------------------------');


/*
 * Доступ к свойству
 * - obj.key
 * - obj['key']
 * - Отсутствующие свойства
 */
console.groupCollapsed('Доступ к свойству объекта'); //! Log group name

// Пример объекта
const playlist = {
  name: 'Мой супер плейлист',
  rating: 5,
  tracks: ['трек-1', 'трек-2', 'трек-3'],
  trackCount: 3,
};

// Первый способ обращения к свой-ам объекта основан на использовании символа "." в синтаксисе обращения. Например, нам нужно получить значение свой-ва "name" из объекта "playlist", для этого используем синтаксическую запись -> "playlist.name" 
console.log('Выводим значение св-ва "name" объекта "playlist" ->', playlist.name) // Выводим в лог значение сво-ва "name" объекта "playlist"

// Другое св-во этого объекта, вызывается точно так-же, путем соответствующей синтаксической записи с использованием символа "." и имени ключа нужного свойства
console.log('Выводим значение св-ва "rating" объекта "playlist" ->', playlist.rating) // Выводим в лог значение сво-ва "rating" объекта "playlist"


// Второй способ обращения к свой-ам объекта основан на использовании некой переменной, внутри которой записано строкой имя нужного свой-сва. В таких случаях для обращения к соответствующему свойству нужно использовать символ двойных квадратных скобок, внутри которых - указывается имя переменной. Например, у нас есть переменная "propertyName", которой присвоено значение - строка с именем свой-ва объекта -> "tracks". Для того, что бы использовать эту переменную и вывести значение указанного в ней свойства объекта - нужно использовать следующий синтаксис записи вызова: "playlist[propertyName]".

const propertyName = 'tracks'; // Объявляем переменную со значением в виде строки - "ключа нужного свойства объекта"

console.log(playlist[propertyName]); // Выводим в "лог" соответствующее свойства объекта, используя в качестве ключа нужного свойства - переменную.


// Ключ свой-ва любого объекта - это всегда строка!


// Обращение к НЕ существующему свойству объекта, всегда возвращает служебный тип данных - "undefined". Появление подобного типа данных, свидетельствует о том, что "запрашиваемый" элемент объекта отсутствует.

// Пример обращения к НЕ существующему свойству объекта
console.log('Выводим значение НЕ существующего сво-ва "qwe" объекта "playlist" ->', playlist.qwe);

console.groupEnd(); //! Log group end
console.log('-2----------------------------------------------');


/*
 * Короткая запись свойств объектов
 */
console.groupCollapsed('Короткая запись свойств объектов'); //! Log group name

// Обычная запись свойств объекта, может быть основана как на прямой записи значения каждого отдельного свойства внутри "тела" объекта, так и на использовании уже существующих в скрипте переменных, которым присвоено нужное значение. Например, у нас есть в скрипте две переменные "username" и "email", которым присвоены строки с нужными значениями, и мы можем их использовать для ввода нужных данных в соответствующие свойства объекта. Для этого, внутри "тела" объекта, в качестве значения соответствующего ключа - мы подставляем имя нужной переменной.

// Создаем переменные для подстановки их значений в свойства объекта
const username = 'Mango';
const email = 'mango@mail.com';

// Создаем переменную "signupData1" и присваиваем ей значение в виде объекта, внутри которого есть 2-а свой-ва "user" и "mail". После чего, присваиваем каждому свойству значение соответствующей переменной, которай была создана ранее.
const signupData1 = { 
  user: username, // Задаем свой-ву "user" значение переменной "username"
  mail: email, // Задаем свой-ву "mail" значение переменной "email"
};

console.log('Значение переменной "signupData1" ->', signupData1); // Выводим в консоль значение переменной "signupData1", т.е. - соответствующий ей объект


// Короткая запись свойств объекта основана на использовании в качестве ключей свойств объектка - имен уже существующих в скрипте переменных

const signupData2 = {
  username, // Используем в качестве имени ключа сво-ва объектка, имя существующей в скрипте переменной
  email, // Используем в качестве имени ключа сво-ва объектка, имя существующей в скрипте переменной
};

console.log('Значение переменной "signupData2" ->', signupData2); // Выводим в консоль значение переменной "signupData2", т.е. - соответствующий ей объект

console.groupEnd(); //! Log group end
console.log('-3----------------------------------------------');

/*
 * Вычисляемые свойства
 */
console.groupCollapsed('Вычисляемые свойства'); //! Log group name

// Предназначены для настройки динамически-изменяемых ключей объекта, и его значений. Например, в неком "инпуте" есть имя и свойство, и нам нужно имя этого инпута - "превратить" в ключ, а свойство - в значение соотвестствующего свойства объекта

//  <input name="color" value="tomato" >

const inputName = 'color'; // Значение этой переменной будет использовано в качестве ключа
const inputValue = 'tomato'; //  Значение этой переменной будет использовано в качестве данных

// Пример объекта с динамически изменяемым ключом свойства и его значения
const colorPickerData = {
  [inputName]: inputValue,
};

// Выводим в консоль объект
console.log('Объект с динамическим вводом ключа и значения свойства ->', colorPickerData);

// Синтаксическая запись ключа объекта с использованием квадратных скобок "[]" позваляет внутрь них подставлять имя существующей в скрипте переменной, а ее значение - как ключ соответствующего объекта.
// Вставка в качестве значения свойства объекта имени существующей в скрипте переменной - позволяет подставить в качестве значения свойства объекта - "соответсвующее значение присвоенное переменной"

console.groupEnd(); //! Log group end
console.log('-4----------------------------------------------');


/*
 * Ссылочный тип {} === {}
 */
console.groupCollapsed('Ссылочный тип {} === {}'); //! Log group name

// Два объекта могут быть равны друг-другу только в том случае, если сравниваются ссылки на один и тот-же объект. Если же, между собой сравнить два отдельносозданных объекта, с одинаковым наполнением - то они всегда будут НЕ равны друг-другу. Дело в том, что для объектов, так же как и для массивов, для каждого отдельного объекта резервируется своя ячейка памяти, и когда сравниваются между собой две отдельные ячейки памяти - они всегда не равны.

// Пример сравнения двух отдельно созданных, но одинаковых по содержанию объектов
console.log('Результат сравнения двух отдельно созданных но одинаковых по содержанию объектов ->', { a: 1 } === { a: 1 });
// Пример сравнения двух отдельно созданных, но одинаковых по содержанию массивов
console.log('Результат сравнения двух отдельно созданных но одинаковых по содержанию массивов ->', [] === []);


// Если мы создадим переменную и присвоим ей объект, а потом присвоим другой переменной значение первой, то мы создадим ссылку, как с первой переменной, так и со второй на один и тот же объект. В этом случае, сравнение двух переменных, которые ссылаются на один и тот-же объект - даст их равенство.
const a = { x: 1, y: 2 }; // Создаем переменную и присваиваем ей значение - объект
const b = a; // Присваиваим новой переменной "b" значение переменной "a", т.е. создаем еще одну ссылку на объект присвоеный переменной "a"

console.log('Сравнение двух переменных ссыллающихся на один и тот же объект ->', b === a);

console.log('Значение переменной "а" =', a); // Выводим в лог значение переменной "а"
console.log('Значение переменной "b" =', b); // Выводим в лог значение переменной "b"

a.x = 100; // Вводим изменения в значение объекта
b.y = 150; // Вводим изменения в значение объекта
console.log('Значение измененной переменной "а" =', a); // Выводим в лог значение переменной "а"
console.log('Значение измененной переменной "b" =', a); // Выводим в лог значение переменной "b"

console.groupEnd(); //! Log group end
console.log('-5----------------------------------------------');


/*
 * Массивы и функции это объекты
 */
console.groupCollapsed('Массивы и функции это объекты'); //! Log group name

// const a = [1, 2, 3];

// a.hello = ':)';

// console.log(a);

// const fn = function () {
//   console.log('hello');
// };

// fn.hello = ';)';

// console.dir(fn.hello);

console.groupEnd(); //! Log group end
console.log('-6----------------------------------------------');